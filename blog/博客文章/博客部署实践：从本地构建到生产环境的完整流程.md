# 博客部署实践：从本地构建到生产环境的完整流程

## 问题背景

整个博客项目是一个前后端分离的架构：前端用 Vue 3 开发，后端用 Go + Gin 框架。最开始我是在本地开发测试，完全跑通之后就要把项目部署到服务器上（其实这是我第一次部署网站，记录一下）。

部署的时候我有两个选择：

- 方案1：在云服务器上安装 Node.js 和 Go 编译器，直接在服务器上构建
  - 优点：部署流程简单，代码更新方便，可以直接到`github`上面拉取新代码后在云服务器上构建运行
  - 缺点：服务器需要安装大量开发工具，占用内存（Node.js 约 800MB，Go 约 1GB），而且生产环境有开发工具也不安全

- 方案2：本地构建，服务器只部署构建产物
  - 优点：服务器环境干净，节省内存，安全性高，本地构建速度通常比服务器快
  - 缺点：需要交叉编译（Windows → Linux），部署流程稍微复杂一点

最后当然是选择方案2，其实也没有复杂多少

## 部署架构

整个部署流程大致是这样的：

```
┌─────────────────┐
│   本地开发环境    │
│  (Windows)      │
└────────┬────────┘
         │
         │ 1. 构建前端 (npm run build)
         │ 2. 交叉编译后端 (GOOS=linux)
         │
         ▼
┌─────────────────┐
│   构建产物       │
│  - dist/        │
│  - main (Linux) │
└────────┬────────┘
         │
         │ 3. SCP 上传到服务器
         │
         ▼
┌─────────────────┐
│   服务器环境      │
│  (Alibaba Cloud)│
│                 │
│  ┌───────────┐  │
│  │  Nginx    │  │ ← 反向代理，处理静态文件和 API 转发
│  └─────┬─────┘  │
│        │        │
│  ┌─────▼─────┐  │
│  │ 前端静态  │   │ ← /var/www/blog/
│  │ 文件      │   │
│  └───────────┘  │
│                 │
│  ┌───────────┐  │
│  │ 后端服务   │  │ ← Systemd 服务，监听 3000 端口
│  │ (Go)      │  │
│  └─────┬─────┘  │
│        │        │
│  ┌─────▼─────┐  │
│  │ MariaDB   │  │ ← 数据库服务
│  └───────────┘  │
└─────────────────┘
```

## 服务器环境准备

> **为何需要服务器？**
> 
> 本地开发环境只能自己访问，要让其他人也能访问你的网站，必须把代码部署到一台 24 小时运行的服务器上。云服务器提供了：
> - **公网 IP**：让全世界的用户都能通过 IP 或域名访问
> - **24 小时运行**：不需要你本地电脑开机，网站随时可访问
> - **固定环境**：Linux 服务器环境稳定，适合运行后端服务和数据库
> - **可扩展性**：可以根据访问量随时升级配置（CPU、内存、带宽等）
> 
> 虽然也可以用自己的电脑做服务器，但需要公网 IP、24 小时开机、处理各种网络问题，成本高且不稳定。云服务器虽然需要付费，但省心省力，是更专业的选择。

### 云服务器购买与域名准备

- **云服务器**

  服务器位置：我买的是阿里云，在阿里云上通过学生认证是有一张代金券的。可惜这张代金券只能用于大陆的云服务器：使用大陆的云服务器部署网站是必须要ICP与公安局备案，而本人只是搞一个不违法乱纪的小网站并不想那么麻烦，所以只能遗憾退场。但是同时为了访问速度，所以我选择了香港的云服务器

  服务器类型：在很久之前我就听说抢占式服务器（按照使用时间与产生流量一小时一小时）非常便宜（除了有被挤掉的些许风险），但是我在早上看到的两分钱/时的抢占式在下午就不见了，最低价格变成三角/时，所以我最后还是不得不去买了个轻量应用服务器

  服务器参数：我选择的是双核2GB/40GB，当然还有更便宜的一核、1GB、20GB

- **域名**

  一事不劳二主，我同样也是在阿里云中买的域名。可惜`keranthos.com`这个域名已经没了，所以我在与朋友讨论之后敲定了`keranthos.me`

  其他域名中

  `.cn`域名也是需要备案的（虽然按理来说其他后缀的域名不需要，但是在购买时阿里云还是会要求去公安部备案后才激活，不过这个相对就非常快，一个小时之内就可以完成），而且之前出现过回收该后缀域名的事件，故我不选；

  `.top`域名更便宜，但是在早期由于注册成本极低，该后缀很多域名被垃圾网站抢注，所以域名的信誉非常不好，故我不选；

  其他的后缀比如`.net`/`.dev`等等就都还可以

### 安装基础服务

服务器用的是阿里云的 Alibaba Cloud Linux，所以用 `yum` 包管理器，下面都是在`ssh`连接了云服务器之后的操作

```bash
# 更新系统
yum update -y

# 安装基础工具
yum install -y curl wget git vim unzip

# 安装 Nginx（反向代理和静态文件服务）
yum install -y nginx
systemctl start nginx
systemctl enable nginx

# 安装 MariaDB（MySQL 的替代，完全兼容）
yum install -y mariadb-server mariadb
systemctl start mariadb
systemctl enable mariadb

# 初始化数据库（设置 root 密码）
mysql_secure_installation
```

**为什么选择 MariaDB 而不是 MySQL？**

我在本地使用的是MySQL，但是其实在 CentOS/Alibaba Cloud Linux 的默认 yum 源里，提供的就是 MariaDB。MariaDB 完全兼容 MySQL 的协议和语法，代码层面不需要任何修改，直接用 `gorm.io/driver/mysql` 驱动就能连接。而且 MariaDB 安装更简单，不需要额外添加仓库。所以在云服务器上使用这个会更好一点。

### 创建数据库和用户

```bash
mysql -u root -p
```

在 MySQL 中执行：

```sql
-- 创建数据库（使用 utf8mb4 字符集，支持 emoji）
CREATE DATABASE my_blog CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci;

-- 创建专用用户（不要直接用 root）
CREATE USER 'blog_user'@'localhost' IDENTIFIED BY '数据库密码';

-- 授权
GRANT ALL PRIVILEGES ON my_blog.* TO 'blog_user'@'localhost';
FLUSH PRIVILEGES;
EXIT;
```

## 本地构建

### 构建前端

前端是 Vue 3 项目，直接用 `npm run build` 就行。生产环境会自动使用相对路径 `/api`，这样可以通过 Nginx 代理统一访问后端 API。

```powershell
cd D:\blog\frontend

# 安装依赖（如果还没安装）
npm install

# 构建生产版本
npm run build
```

构建完成后，`frontend/dist/` 目录包含所有静态文件（HTML、JS、CSS、图片等）。

### 交叉编译后端

后端是 Go 项目，需要交叉编译成 Linux 可执行文件。Go 的交叉编译很简单，只需要设置环境变量就行。

```powershell
cd D:\blog\backend

# 设置目标平台（Linux amd64）
$env:GOOS="linux"
$env:GOARCH="amd64"

# 编译
go build -o main.exe main.go
```

编译完成后，`backend/main.exe` 就是 Linux 可执行文件了。

**验证编译结果（在 Git Bash 中）：**

```bash
file backend/main.exe
# 应该显示：ELF 64-bit LSB executable, x86-64
```

## 准备配置文件

### 创建服务器端配置文件

在本地创建 `backend/config/config.yml`（参考 `config.yml.example`）：

```yaml
app:
  name: "Blog"
  port: "3000"

database:
  host: "localhost"
  port: "3306"
  username: "blog_user"
  password: "数据库密码"  # 改为上面设置的密码
  name: "my_blog"

jwt:
  secretkey: "你的JWT密钥"  # 建议使用 openssl rand -hex 32 生成
  expiration: 86400
```

**生成 JWT 密钥（在 Git Bash 中）：**

```bash
openssl rand -hex 32
# 将输出复制到 config.yml 的 secretkey 字段
```

### 创建服务器目录结构

在服务器上执行：

```bash
# 创建项目目录
mkdir -p /opt/blog/backend
mkdir -p /opt/blog/backend/uploads/images/content
mkdir -p /opt/blog/backend/uploads/images/media
mkdir -p /var/www/blog

# 设置权限
chmod -R 755 /opt/blog/backend/uploads
```

## 上传文件到服务器

### 使用 SCP 上传

在本地 Windows PowerShell 中执行：

```powershell
# 1. 上传前端构建文件
# 将 YOUR_SERVER_IP 替换为你的服务器 IP 地址
scp -r frontend/dist/* root@YOUR_SERVER_IP:/var/www/blog/

# 2. 上传后端二进制文件
scp backend/main.exe root@YOUR_SERVER_IP:/opt/blog/backend/main

# 3. 上传配置文件
scp backend/config/config.yml root@YOUR_SERVER_IP:/opt/blog/backend/config/
```

**设置后端文件权限：**

```bash
cd /opt/blog/backend
chmod +x main  # 给可执行文件添加执行权限
```

## 初始化数据库

⚠️ 重要：表结构是在后端程序首次运行时自动创建的，而不是手动创建。必须先运行后端程序！

数据安全说明

- `AutoMigrate` 不会删除已有数据和表
- 如果表已存在，只会添加缺失的列，不会删除列或数据
- 如果表不存在，才会创建新表
- 每次启动时，只是检查和更新表结构（增量更新）

### 首次运行后端

在服务器上执行：

```bash
cd /opt/blog/backend

# 确保文件有执行权限
chmod +x main

# 运行后端程序（会输出日志）
GIN_MODE=release ./main
```

**预期输出（成功的情况）：**

```
Created directory: uploads
Created directory: uploads/images
开始创建数据库索引...
数据库索引创建完成
```

**注意：** 
- 程序会一直运行（这是正常的！），不会自动退出
- 看到"数据库索引创建完成"说明程序已成功启动，表已经创建
- 首次运行会创建表，后续运行只会检查并更新表结构，不会删除任何数据

**验证程序正在运行：**

在另一个终端窗口（或新开一个SSH连接）执行：

```bash
# 注意：URL 必须用引号括起来，否则 & 会被 shell 解析
curl "http://localhost:3000/api/articles?type=blog&page=1&limit=10"
```

- 如果返回 JSON 数据，说明程序正常运行
- 如果返回错误信息（如 `{"error":"..."}`），说明程序在运行，只是参数问题
- 如果返回 `curl: (7) Failed to connect`，说明程序可能没有启动

确认程序正常运行后，在原终端按 `Ctrl+C` 停止程序。

### 验证表是否创建

```bash
mysql -u blog_user -p my_blog
```

在 MySQL 中执行：

```sql
SHOW TABLES;
```

**预期结果（应该看到以下表）：**

```
+--------------------------+
| Tables_in_my_blog         |
+--------------------------+
| blog_articles            |
| comments                 |
| media                    |
| moments                  |
| presentations            |
| project_articles         |
| questions                |
| research_articles        |
| users                    |
| weather                  |
+--------------------------+
```

## 配置 Nginx

Nginx 的作用有两个：
1. **静态文件服务**：直接返回前端构建的 HTML、JS、CSS 等文件
2. **反向代理**：将 `/api/*` 请求转发到后端服务（`http://127.0.0.1:3000`）

### 创建 Nginx 配置文件

```bash
# 将 你的域名.conf 替换为实际域名，如 example.com.conf
vim /etc/nginx/conf.d/你的域名.conf
```

**完整配置内容：**

```nginx
server {
    listen 80;
    # 将 你的域名 替换为实际域名
    server_name 你的域名 www.你的域名;
    
    # 前端静态文件根目录
    root /var/www/blog;
    index index.html;
    
    # 日志配置
    access_log /var/log/nginx/keranthos_access.log;
    error_log /var/log/nginx/keranthos_error.log;
    
    # Gzip 压缩
    gzip on;
    gzip_vary on;
    gzip_min_length 1024;
    gzip_types text/plain text/css text/xml text/javascript application/javascript application/json application/xml;
    gzip_comp_level 6;
    
    # 静态资源缓存策略
    location ~* \.(js|css|woff|woff2|ttf|eot|svg)$ {
        expires 365d;
        add_header Cache-Control "public, immutable";
        access_log off;
    }
    
    location ~* \.(jpg|jpeg|png|gif|ico|webp)$ {
        expires 90d;
        add_header Cache-Control "public";
        access_log off;
    }
    
    # HTML 文件不缓存（确保更新及时）
    location ~* \.html$ {
        expires -1;
        add_header Cache-Control "no-cache, no-store, must-revalidate";
    }
    
    # API 代理（转发到后端）
    location /api/ {
        proxy_pass http://127.0.0.1:3000/;
        proxy_http_version 1.1;
        proxy_set_header Upgrade $http_upgrade;
        proxy_set_header Connection 'upgrade';
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
        proxy_cache_bypass $http_upgrade;
    }
    
    # 上传文件代理（如果需要直接访问上传的文件）
    location /uploads/ {
        alias /opt/blog/backend/uploads/;
        expires 90d;
        add_header Cache-Control "public";
    }
    
    # Vue Router 的 history 模式支持
    location / {
        try_files $uri $uri/ /index.html;
    }
}
```

**关键配置说明：**

1. **静态资源缓存**：
   - JS/CSS/字体：365 天长期缓存（文件名带 hash，更新时会变）
   - 图片：90 天缓存
   - HTML：不缓存（确保更新及时）

2. **API 代理**：
   - `/api/*` 请求转发到 `http://127.0.0.1:3000/`
   - 注意 `proxy_pass` 后面的路径包含 `/`，这样会去掉 `/api` 前缀

3. **Vue Router 支持**：
   - `try_files` 确保前端路由能正常工作（刷新页面不会 404）

### 测试并重新加载 Nginx

```bash
# 测试配置
nginx -t

# 重新加载（不中断服务）
systemctl reload nginx
```

## 配置后端服务

为了让后端服务在服务器重启后自动启动，需要创建 `Systemd` 服务文件。

### 创建 `Systemd` 服务文件

```bash
vim /etc/systemd/system/blog-backend.service
```

内容：

```ini
[Unit]
Description=Blog Backend Service
After=network.target mariadb.service

[Service]
Type=simple
User=root
WorkingDirectory=/opt/blog/backend
ExecStart=/opt/blog/backend/main
Restart=always
RestartSec=5s
Environment=GIN_MODE=release

# 日志
StandardOutput=journal
StandardError=journal
SyslogIdentifier=blog-backend

[Install]
WantedBy=multi-user.target
```

**配置说明：**

- `After=network.target mariadb.service`：确保网络和数据库服务启动后再启动后端
- `Restart=always`：服务异常退出时自动重启
- `RestartSec=5s`：重启前等待 5 秒
- `Environment=GIN_MODE=release`：生产模式，减少日志输出

### 启用并启动服务

```bash
# 重新加载 systemd
systemctl daemon-reload

# 启用服务（开机自启）
systemctl enable blog-backend

# 启动服务
systemctl start blog-backend

# 查看状态
systemctl status blog-backend

# 查看日志（实时）
journalctl -u blog-backend -f
```

## 配置 Cloudflare

Cloudflare 是一个免费的 CDN 和 DNS 服务，可以提供：
- **CDN 加速**：将静态资源缓存到全球节点，加速访问
- **DDoS 防护**：自动防护常见的网络攻击
- **隐藏真实 IP**：通过代理模式隐藏服务器真实 IP
- **免费 SSL**：虽然我们用的是 Let's Encrypt，但 CF 也提供免费证书

### 添加域名到 Cloudflare

1. **注册 Cloudflare 账号**（如果还没有）
   - 访问 [Cloudflare 官网](https://www.cloudflare.com)
   - 注册账号并登录

2. **添加站点**
   - 在控制台点击 **Add a Site**
   - 输入域名 
   - 选择计划

3. **修改 DNS 记录**
   - Cloudflare 会自动扫描现有 DNS 记录
   - 确认 A 记录指向服务器 IP（将 `YOUR_SERVER_IP` 替换为你的服务器 IP）
   - 确认 `www` 子域名也指向服务器 IP

4. **更新域名服务器（Nameservers）**
   - Cloudflare 会提供两个 Nameservers（如 `xxx.ns.cloudflare.com`）
   - 在阿里云域名控制台，将域名的 Nameservers 改为 Cloudflare 提供的
   - 等待 DNS 生效（通常几分钟到几小时）

### 配置 Cloudflare DNS

在 Cloudflare 控制台的 **DNS** 页面，确保有以下记录：

- **A 记录**：`你的域名` → `YOUR_SERVER_IP`，**代理状态：仅DNS（橙色云朵关闭）**
- **A 记录**：`www.你的域名` → `YOUR_SERVER_IP`，**代理状态：仅DNS（橙色云朵关闭）**

> **为何需要 Cloudflare？**
> 
> Cloudflare 是一个免费的 CDN 和 DNS 服务，虽然不必须，但强烈推荐使用，原因如下：
> - **CDN 加速**：将静态资源（JS、CSS、图片）缓存到全球节点，用户访问时从最近的节点获取，大幅提升加载速度
> - **DDoS 防护**：自动防护常见的网络攻击（如 DDoS、CC 攻击），保护服务器不被攻击瘫痪
> - **隐藏真实 IP**：通过代理模式，用户访问的是 Cloudflare 的 IP，而不是你的服务器 IP，降低被攻击的风险
> - **免费 SSL**：虽然我们用的是 Let's Encrypt，但 CF 也提供免费证书，可以作为备选
> - **节省带宽**：静态资源通过 CF 的 CDN 分发，不消耗服务器带宽，降低服务器成本
> 
> 对于个人博客来说，Cloudflare 免费版已经足够使用，不需要付费。

**注意：** 在申请 SSL 证书时，必须保持代理状态为"仅DNS"（橙色云朵关闭），否则 Let's Encrypt 无法验证域名所有权。

### 配置 Nginx 获取真实 IP（如果使用 CF 代理）

如果后续开启了 Cloudflare 代理（橙色云朵），需要配置 Nginx 从 `CF-Connecting-IP` 头部获取真实 IP。

**创建 Cloudflare IP 配置文件：**

```bash
vim /etc/nginx/cloudflare.conf
```

内容：

```nginx
# Cloudflare IP 段（2024年更新）
set_real_ip_from 103.21.244.0/22;
set_real_ip_from 103.22.200.0/22;
set_real_ip_from 103.31.4.0/22;
set_real_ip_from 104.16.0.0/13;
set_real_ip_from 104.24.0.0/14;
set_real_ip_from 108.162.192.0/18;
set_real_ip_from 131.0.72.0/22;
set_real_ip_from 141.101.64.0/18;
set_real_ip_from 162.158.0.0/15;
set_real_ip_from 172.64.0.0/13;
set_real_ip_from 173.245.48.0/20;
set_real_ip_from 188.114.96.0/20;
set_real_ip_from 190.93.240.0/20;
set_real_ip_from 197.234.240.0/22;
set_real_ip_from 198.41.128.0/17;
# IPv6
set_real_ip_from 2400:cb00::/32;
set_real_ip_from 2606:4700::/32;
set_real_ip_from 2803:f800::/32;
set_real_ip_from 2405:b500::/32;
set_real_ip_from 2405:8100::/32;
set_real_ip_from 2c0f:f248::/32;
set_real_ip_from 2a06:98c0::/29;

# 从 CF-Connecting-IP 头部获取真实 IP
real_ip_header CF-Connecting-IP;
```

**在主配置文件中引入：**

编辑 `/etc/nginx/nginx.conf`，在 `http` 块中添加：

```nginx
http {
    # ... 其他配置 ...
    
    # Cloudflare 真实 IP 配置（如果使用 CF 代理）
    include /etc/nginx/cloudflare.conf;
    
    # ... 其他配置 ...
}
```

**注意：** 如果只使用 Cloudflare DNS（不开启代理），可以跳过此步骤。等申请完 SSL 证书并开启代理后，再配置也不迟。

## 配置 HTTPS（SSL证书）

### 安装 `Certbot`

```bash
# CentOS/Alibaba Cloud Linux 需要先安装 EPEL
yum install -y epel-release
yum install -y certbot python3-certbot-nginx
```

### 申请 SSL 证书

⚠️ 重要：申请证书时必须关闭 Cloudflare 代理（仅DNS模式），证书申请成功后再开启。

在 Cloudflare 控制台确认：
- A记录：`你的域名` → `YOUR_SERVER_IP`，代理状态：仅DNS（橙色云朵关闭）
- A记录：`www.你的域名` → `YOUR_SERVER_IP`，代理状态：仅DNS（橙色云朵关闭）

```bash
# 将 你的域名 替换为实际域名
certbot --nginx -d 你的域名 -d www.你的域名
```

按提示操作：
- 输入邮箱地址
- 同意服务条款（A）
- 选择是否共享邮箱（N）
- 选择是否重定向 HTTP 到 HTTPS（2，推荐选择重定向）

### 测试证书自动续期

```bash
certbot renew --dry-run
```

Let's Encrypt 证书有效期 90 天，`Certbot` 会自动续期（需要配置定时任务）。

### 开启 Cloudflare 代理

证书申请成功后，在 Cloudflare 控制台将 DNS 记录的代理状态改为：已代理（橙色云朵开启）

## 配置防火墙和安全组

### 阿里云安全组配置

⚠️ 必须在阿里云控制台配置安全组规则，否则无法访问！

1. 登录 阿里云控制台
2. 进入 服务器 → 实例 → 找到你的服务器
3. 点击 安全组 → 配置规则 → 入方向 → 添加安全组规则
4. 添加以下规则：
   - `22/tcp` (SSH) - 授权对象：你的IP或 0.0.0.0/0（不推荐，建议限制IP）
   - `80/tcp` (HTTP) - 授权对象：0.0.0.0/0
   - `443/tcp` (HTTPS) - 授权对象：0.0.0.0/0
   - `3000/tcp` (后端服务，仅限内网) - 授权对象：127.0.0.1/32

**注意：** 3000 端口只对本地开放，因为后端服务只通过 Nginx 代理访问，不需要对外暴露。

### 系统防火墙（可选）

**检查系统防火墙状态：**

```bash
systemctl status firewalld
```

**如果启用了防火墙，配置规则：**

```bash
firewall-cmd --permanent --add-service=http
firewall-cmd --permanent --add-service=https
firewall-cmd --permanent --add-service=ssh
firewall-cmd --reload
```

**如果不需要系统防火墙（阿里云安全组已提供保护）：**

```bash
systemctl stop firewalld
systemctl disable firewalld
```

**注意：** 阿里云的安全组已经提供了网络层防火墙，系统防火墙通常是关闭的。建议保持系统防火墙关闭，避免配置冲突。

## 验证部署

### 验证清单

- [ ] **前端验证**
  - 访问 `https://你的域名` 能正常显示
  - 路由跳转正常（各个界面）
  - 图片能正常加载

- [ ] **后端验证**
  - API 请求正常：`curl https://你的域名/api/articles?type=blog&page=1&limit=10`
  - 登录功能正常
  - 图片上传功能正常

- [ ] **数据库验证**
  ```bash
  mysql -u blog_user -p my_blog
  SHOW TABLES;
  # 应该能看到 blog_articles, research_articles 等表
  EXIT;
  ```

- [ ] **服务状态验证**
  ```bash
  systemctl status blog-backend
  systemctl status nginx
  systemctl status mariadb
  ```

## 后续维护

### 更新前端代码

**当需要更新前端代码时：**

1. **本地构建（Windows）：**
   ```powershell
   cd D:\blog\frontend
   npm install  # 如果 package.json 有更新
   npm run build
   ```

2. **上传到服务器：**
   ```powershell
   # 增量更新（推荐，只覆盖同名文件）
   # 将 YOUR_SERVER_IP 替换为你的服务器 IP 地址
   scp -r frontend/dist/* root@YOUR_SERVER_IP:/var/www/blog/
   
   # 完全清理后更新（如果有缓存问题）
   ssh root@YOUR_SERVER_IP "rm -rf /var/www/blog/*"
   scp -r frontend/dist/* root@YOUR_SERVER_IP:/var/www/blog/
   ```

3. **清除 Cloudflare 缓存（如果使用 CF）：**
   - 登录 Cloudflare 控制台
   - 进入 Caching → Purge Everything

### 更新后端代码

**当需要更新后端代码时：**

1. **本地构建（Windows）：**
   ```powershell
   cd D:\blog\backend
   $env:GOOS="linux"
   $env:GOARCH="amd64"
   go build -o main.exe main.go
   ```

2. **上传到服务器：**
   ```powershell
   # 先停止服务避免文件锁定
   # 将 YOUR_SERVER_IP 替换为你的服务器 IP 地址
   ssh root@YOUR_SERVER_IP "systemctl stop blog-backend"
   
   # 上传新文件
   scp backend/main.exe root@YOUR_SERVER_IP:/opt/blog/backend/main.new
   
   # 替换文件并重启服务
   ssh root@YOUR_SERVER_IP "cd /opt/blog/backend && mv -f main.new main && chmod +x main && systemctl start blog-backend"
   ```

3. **验证服务：**
   ```bash
   systemctl status blog-backend
   journalctl -u blog-backend -f
   ```

## 后续优化方向

当前部署方案已经可以稳定运行，但随着项目规模增长，可以考虑以下优化：

### 1. OSS 对象存储（图片/文件分离）

> **为何需要 OSS？**
> 
> 当前方案中，图片和文件存储在服务器本地，虽然简单直接，但随着内容增多会面临以下问题：
> - **磁盘空间限制**：服务器磁盘容量有限（通常 20-40GB），图片多了容易占满，需要频繁清理或升级服务器
> - **带宽消耗**：图片访问会消耗服务器带宽，如果图片较大或访问量大，可能超出服务器带宽限制
> - **访问速度**：所有图片请求都要经过服务器，如果服务器在海外，国内用户访问会很慢
> - **备份困难**：服务器磁盘故障可能导致图片丢失，需要手动备份
> 
> OSS（对象存储）专门用于存储静态文件，解决了以上问题：
> - **无限容量**：按需付费，理论上可以存储无限文件
> - **CDN 加速**：OSS 自带 CDN，图片访问速度更快，全球用户都能快速加载
> - **节省带宽**：图片直接从 OSS CDN 获取，不消耗服务器带宽
> - **自动备份**：OSS 提供多副本存储，数据更安全
> - **额外功能**：支持图片自动压缩、格式转换（WebP）、水印等功能
> 
> 对于个人博客，如果图片不多（< 10GB），可以暂时不用 OSS。但如果图片较多或希望提升访问速度，建议迁移到 OSS。

**现状问题：**
- 图片和文件存储在服务器本地，占用服务器磁盘空间
- 服务器磁盘容量有限（40GB），图片多了容易占满
- 图片访问会消耗服务器带宽

**优化方案：**
- 使用阿里云 OSS（对象存储）或腾讯云 COS 存储图片
- 后端上传图片时直接上传到 OSS，返回 OSS 的 CDN 地址
- 前端直接通过 OSS CDN 访问图片，不经过服务器

**实现步骤：**
1. 在阿里云控制台创建 OSS Bucket
2. 配置 OSS 的 CDN 加速域名
3. 修改后端图片上传逻辑，使用 OSS SDK 上传
4. 修改前端图片显示逻辑，使用 OSS CDN 地址

**优势：**
- 节省服务器磁盘空间（图片不占服务器空间）
- 图片访问更快（CDN 加速）
- 降低服务器带宽消耗
- 支持图片自动压缩、格式转换等功能

### 2. 前后端完全分离部署

**现状：**
- 前端静态文件部署在服务器上（`/var/www/blog/`）
- 每次更新前端需要 SSH 上传文件

**优化方案：**
- 前端部署到静态托管服务（如 Vercel、Netlify、GitHub Pages）
- 或者使用阿里云 OSS + CDN 托管前端静态文件
- 后端 API 独立部署，前端通过 API 域名访问

**实现步骤：**
1. 前端构建后上传到静态托管服务
2. 配置自定义域名指向静态托管
3. 前端 API 地址改为后端服务器域名
4. 配置 CORS 允许前端域名访问后端 API

**优势：**
- 前端更新更方便（自动部署）
- 前端访问更快（CDN 加速）
- 前后端可以独立扩展
- 降低服务器负载

### 3. 数据库优化

**现状：**
- 数据库和应用程序在同一台服务器
- 使用 MariaDB，单机部署

**优化方案：**
- 使用云数据库 RDS（如阿里云 RDS MySQL）
- 或者数据库单独部署到另一台服务器
- 配置数据库主从复制（读写分离）

**优势：**
- 数据库独立管理，不影响应用服务器
- 自动备份，数据更安全
- 读写分离提升性能
- 支持数据库监控和告警

### 4. 容器化部署（Docker）

**现状：**
- 直接在服务器上运行二进制文件
- 环境依赖需要手动配置

**优化方案：**
- 使用 Docker 容器化部署
- 编写 Dockerfile 和 docker-compose.yml
- 使用 Docker 管理前后端服务

**优势：**
- 环境一致性更好（开发、测试、生产环境一致）
- 部署更简单（一条命令启动所有服务）
- 易于扩展和维护
- 支持滚动更新，零停机部署

### 5. CI/CD 自动化部署

**现状：**
- 手动构建、上传、重启服务
- 更新流程繁琐

**优化方案：**
- 使用 GitHub Actions 或 GitLab CI
- 代码推送到仓库后自动构建、测试、部署
- 自动化执行部署脚本

**实现步骤：**
1. 在代码仓库配置 CI/CD 流程
2. 编写部署脚本（构建、上传、重启）
3. 配置服务器 SSH 密钥
4. 推送代码后自动触发部署

**优势：**
- 部署流程自动化，减少人工错误
- 支持自动化测试
- 可以配置多环境部署（开发、测试、生产）
- 部署历史可追溯

**注意：** 对于个人博客这种规模的项目，当前方案已经足够。以上优化方向可以根据实际需求逐步实施，不需要一开始就全部实现。

## 总结

这套部署方案的步骤大约如下

| 环节 | 实现方式 | 优势 |
|------|---------|------|
| **构建** | 本地构建 + 交叉编译 | 节省服务器资源，构建速度快 |
| **上传** | SCP 直接传输 | 简单直接，无需额外工具 |
| **静态文件** | Nginx 直接服务 | 性能好，支持缓存策略 |
| **API 代理** | Nginx 反向代理 | 统一入口，隐藏后端端口 |
| **后端服务** | `Systemd` 管理 | 自动重启，开机自启 |
| **HTTPS** | Let's Encrypt 免费证书 | 自动续期，零成本 |
| **CDN** | Cloudflare 代理 | 加速访问，隐藏真实 IP |

整个流程虽然步骤较多，但每一步都有明确的目的，而且大部分配置都是一次性的，后续只需要更新代码文件就行。对于个人博客这种规模的项目，这套方案已经足够稳定和高效了。
