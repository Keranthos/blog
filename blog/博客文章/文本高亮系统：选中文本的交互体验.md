# 文本高亮系统：选中文本的交互体验

## 背景

前不久我嫌弃文章阅读的时候选中特效太过难看，就为文章详情页中的文本加上了一层选中特效。但是按理来说在选中之后，肯定是需要对这些文本做一些操作比如复制等等，于是我又为选中文本做了复制、高亮与分享三个按键。

复制与分享卡片很好做，但是高亮就比较麻烦，主要面临了下面几个问题：

- 在选中高亮文本的时候，高亮是否能解除？那选中的文本要是部分高亮部分未高亮呢？
- 高亮的文本是只有高亮/未高亮两种状态，还是支持嵌套高亮？
- 读者高亮的时候是不会在意选中的区域是否属于同一个DOM，但是我在渲染高亮的时候不能一个字一个字的渲染（这样会出现很大的空隙）而是应该将一行中的所有文本连成一片来渲染

最终为了避免过于复杂的逻辑判断，我直接没有做取消高亮的功能；嵌套高亮太不美观所以也不能用常规的选一段文本存一段数组的方式，那样会导致嵌套高亮（即一段文本被高亮多次）；而关于如何渲染，我一开始的做法是将选中的所有内容包括进一个DOM来整体渲染，但是那样会极大影响选中文本内部与相邻DOM的结构。所以就使用了另外一种方法。

## 监听选区并计算菜单位置

页面挂载时会监听 `document` 的 `mouseup` 事件，只要当前选区落在 Markdown 容器内，就记录 `Range`、计算菜单显示位置，并判断是否已经高亮过。

```javascript
// 鼠标抬起时触发，尝试捕获用户的选区
const handleTextSelection = (e) => {
  // 如果点击的是浮动菜单本身，则不做处理，避免关闭菜单
  if (e.target && (e.target.closest('.text-selection-menu') || e.target.closest('.menu-btn'))) {
    return
  }

  const selection = window.getSelection()
  const selectedTextValue = selection.toString().trim() // 去掉前后空白

  // 没有选中任何字符，或者文章容器尚未挂载，则直接隐藏菜单
  if (!selectedTextValue || !articleContentRef.value) {
    textSelectionMenuVisible.value = false
    return
  }

  // 只允许在正文（Markdown 渲染结果）内出现菜单
  const markdownBody = articleContentRef.value.querySelector('.markdown-body')
  if (!markdownBody || !markdownBody.contains(selection.anchorNode)) {
    textSelectionMenuVisible.value = false
    return
  }

  const range = selection.getRangeAt(0).cloneRange() // 克隆 range，防止后续被清空
  const rect = range.getBoundingClientRect() // 获取选区在视口中的位置

  // 计算菜单中心点位置（X 轴居中，Y 轴在选区上方）
  textSelectionPosition.value = {
    x: rect.left + rect.width / 2,
    y: rect.top
  }

  selectedText.value = selectedTextValue // 存储文本内容，供复制/分享使用
  highlightedRange.value = range // 记住 Range，稍后高亮时还能用
  isTextHighlighted.value = checkIfHighlighted(range) // 判断是否已经高亮过
  textSelectionMenuVisible.value = true // 显示菜单
}
```

`TextSelectionMenu` 组件负责菜单的具体绘制。它会根据视口尺寸调整位置，避免跑出屏幕，同时在按钮事件里阻止冒泡，防止点击菜单时选区被清空。

```vue
<div
  v-if="visible"
  ref="menuRef"
  class="text-selection-menu"
  :style="menuStyle"
  @mousedown.prevent.stop
>
  <!-- 复制按钮：触发父组件的 copy 事件 -->
  <button class="menu-btn" @click="handleCopy" @mousedown.prevent>
    <font-awesome-icon icon="copy" class="menu-icon" />
    <span class="menu-text">复制</span>
  </button>

  <!-- 高亮按钮：根据 isHighlighted 切换样式 -->
  <button class="menu-btn" :class="{ active: isHighlighted }" @click="handleHighlight" @mousedown.prevent>
    <font-awesome-icon icon="highlighter" class="menu-icon" />
    <span class="menu-text">高亮</span>
  </button>

  <!-- 分享按钮：触发 share 事件，父组件会弹出分享卡片 -->
  <button class="menu-btn" @click="handleShare" @mousedown.prevent>
    <font-awesome-icon icon="share" class="menu-icon" />
    <span class="menu-text">分享</span>
  </button>
</div>
```

## 安全地包裹高亮，不扰乱 Markdown 与代码块

高亮逻辑会遍历选区内的所有文本节点，跳过 highlight.js 注入的 `hljs-*` 元素。如果选区跨越多个块级元素，会逐行拆分，只对未高亮的部分创建 `<span class="text-highlight">`。一旦检测到选区完全位于既有高亮里，就直接退出，避免出现嵌套导致的颜色加深或结构破坏。

## 高亮算法：只包裹未着色的文本

高亮按钮触发的核心逻辑在 `handleTextHighlight`，它会根据选区动态拆分文本节点，只包裹尚未着色的部分，并在必要时降级为手动分割，保证 DOM 结构稳定。

```javascript
// 用户点击“高亮”按钮后的主流程
const handleTextHighlight = async (text) => {
  if (!highlightedRange.value) return

  const selection = window.getSelection()
  let range = null

  // 优先使用当前选区，否则退回上一段缓存的 Range
  if (selection.rangeCount > 0) {
    range = selection.getRangeAt(0).cloneRange()
  } else if (highlightedRange.value) {
    range = highlightedRange.value.cloneRange()
  }

  if (!range || range.collapsed) {
    showCustomMessage('请先选择文本')
    return
  }

  // 如果选区已经完全在高亮区域，则不重复处理
  if (isRangeFullyHighlighted(range)) {
    textSelectionMenuVisible.value = false
    selectedText.value = ''
    highlightedRange.value = null
    window.getSelection().removeAllRanges()
    return
  }

  // 需要特殊处理的块级元素列表
  const blockElements = ['P', 'DIV', 'LI', 'H1', 'H2', 'H3', 'H4', 'H5', 'H6', 'UL', 'OL', 'DL', 'DT', 'DD', 'BLOCKQUOTE', 'PRE', 'CODE', 'TABLE', 'TR', 'TD', 'TH', 'THEAD', 'TBODY']
  const containsBlockElement = () => {
    const commonAncestor = range.commonAncestorContainer
    const startContainer = range.startContainer
    const endContainer = range.endContainer

    // 向上查找祖先节点，只要命中块级元素就需要逐行拆分
    const checkNode = (node) => {
      let current = node.nodeType === Node.TEXT_NODE ? node.parentElement : node
      while (current && current !== commonAncestor) {
        if (blockElements.includes(current.tagName)) {
          return true
        }
        current = current.parentElement
      }
      return false
    }

    return checkNode(startContainer) || checkNode(endContainer)
  }

  if (containsBlockElement()) {
    const textNodes = getTextNodesInRange(range)
    let hasHighlight = false

    textNodes.forEach(textNode => {
      let startOffset = 0
      let endOffset = textNode.textContent.length

      // 对于起始/结尾文本节点，使用精确的偏移量
      if (textNode === range.startContainer) startOffset = range.startOffset
      if (textNode === range.endContainer) endOffset = range.endOffset

      if (endOffset > startOffset) {
        // 查找当前文本节点是否已经被高亮或位于 highlight.js 的节点内
        let current = textNode.parentElement
        let highlightSpan = null
        while (current) {
          if (current.classList && current.classList.contains('text-highlight')) {
            highlightSpan = current
            break
          }
          if (current.classList && Array.from(current.classList).some(cls => cls.startsWith('hljs-'))) {
            current = current.parentElement
            continue
          }
          if (current === articleContentRef.value || current.classList?.contains('markdown-body')) break
          current = current.parentElement
        }

        let highlightStart = null
        let highlightEnd = null

        if (highlightSpan) {
          const highlightRange = document.createRange()
          highlightRange.selectNodeContents(highlightSpan)
          if (highlightRange.intersectsNode(textNode)) {
            const textNodeRange = document.createRange()
            textNodeRange.selectNodeContents(textNode)

            const startCompare = highlightRange.compareBoundaryPoints(Range.START_TO_START, textNodeRange)
            const endCompare = highlightRange.compareBoundaryPoints(Range.END_TO_END, textNodeRange)

            if (highlightRange.startContainer === textNode) {
              highlightStart = highlightRange.startOffset
            } else if (startCompare <= 0) {
              highlightStart = 0
            }

            if (highlightRange.endContainer === textNode) {
              highlightEnd = highlightRange.endOffset
            } else if (endCompare >= 0) {
              highlightEnd = textNode.textContent.length
            }

            if (highlightStart === null || highlightEnd === null) {
              if (startCompare <= 0 && endCompare >= 0) {
                highlightStart = 0
                highlightEnd = textNode.textContent.length
              }
            }
          }
        }

        let needHighlightStart = startOffset
        let needHighlightEnd = endOffset

        if (highlightStart !== null && highlightEnd !== null) {
          if (startOffset < highlightEnd && endOffset > highlightStart) {
            if (startOffset >= highlightStart && endOffset <= highlightEnd) {
              return
            }
            if (startOffset < highlightStart && endOffset > highlightStart) {
              needHighlightEnd = Math.min(endOffset, highlightStart)
            } else if (startOffset < highlightEnd && endOffset > highlightEnd) {
              needHighlightStart = Math.max(startOffset, highlightEnd)
            }
          }
        }

        // 只对未高亮的区间执行包裹操作
        if (needHighlightEnd > needHighlightStart) {
          try {
            const highlightRange = document.createRange()
            highlightRange.setStart(textNode, needHighlightStart)
            highlightRange.setEnd(textNode, needHighlightEnd)

            // 向上查找祖先节点，若已在高亮或 hljs span 中则跳过
            let parent = textNode.parentElement
            while (parent) {
              if (parent.classList?.contains('text-highlight')) return
              if (Array.from(parent.classList || []).some(cls => cls.startsWith('hljs-'))) {
                parent = parent.parentElement
                continue
              }
              if (parent === articleContentRef.value || parent.classList?.contains('markdown-body')) break
              parent = parent.parentElement
            }

            const span = document.createElement('span')
            span.className = 'text-highlight'
            span.style.setProperty('display', 'inline', 'important')
            span.style.setProperty('background-color', 'rgba(168, 85, 247, 0.4)', 'important')
            span.style.setProperty('padding', '0', 'important')
            span.style.setProperty('margin', '0', 'important')
            span.style.setProperty('line-height', 'inherit', 'important')

            highlightRange.surroundContents(span)
            hasHighlight = true
          } catch (e) {
            // surroundContents 失败时降级为手动拆分文本
            const text = textNode.textContent
            const beforeText = text.substring(0, needHighlightStart)
            const highlightText = text.substring(needHighlightStart, needHighlightEnd)
            const afterText = text.substring(needHighlightEnd)
            const parent = textNode.parentNode

            if (parent && highlightText.trim()) {
              if (beforeText) parent.insertBefore(document.createTextNode(beforeText), textNode)
              const span = document.createElement('span')
              span.className = 'text-highlight'
              span.style.setProperty('display', 'inline', 'important')
              span.style.setProperty('background-color', 'rgba(168, 85, 247, 0.4)', 'important')
              span.textContent = highlightText
              parent.insertBefore(span, textNode)
              if (afterText) parent.insertBefore(document.createTextNode(afterText), textNode)
              parent.removeChild(textNode)
              hasHighlight = true
            }
          }
        }
      }
    })

    if (hasHighlight) {
      saveHighlights()
      window.getSelection().removeAllRanges()
      textSelectionMenuVisible.value = false
      selectedText.value = ''
      highlightedRange.value = null
    }
  }
}
```

## 高亮数据的持久化与恢复

为了在同一浏览器会话内保留阅读痕迹，新增高亮后都会调用 `saveHighlights` 写入 `sessionStorage`；页面加载完成时再执行 `restoreHighlights`，逐条匹配原文并恢复。

```javascript
// 将当前高亮的文本写入 sessionStorage
const saveHighlights = () => {
  if (!articleContentRef.value) return

  const id = props.articleId || route.params.id
  if (!id || id === 'undefined') return

  const markdownBody = articleContentRef.value.querySelector('.markdown-body')
  if (!markdownBody) return

  const highlights = markdownBody.querySelectorAll('.text-highlight')
  const highlightData = Array.from(highlights)
    .map(highlight => highlight.textContent.trim())
    .filter(text => text.length > 0)

  const storageKey = `article-highlights-${props.type}-${id}`
  if (highlightData.length > 0) {
    sessionStorage.setItem(storageKey, JSON.stringify(highlightData))
  } else {
    sessionStorage.removeItem(storageKey)
  }
}

// 从 sessionStorage 恢复高亮
const restoreHighlights = () => {
  if (!articleContentRef.value) return

  const id = props.articleId || route.params.id
  if (!id || id === 'undefined') return

  const markdownBody = articleContentRef.value.querySelector('.markdown-body')
  if (!markdownBody) return

  const storageKey = `article-highlights-${props.type}-${id}`
  const savedHighlights = sessionStorage.getItem(storageKey)
  if (!savedHighlights) return

  const highlightTexts = JSON.parse(savedHighlights)
  if (!Array.isArray(highlightTexts) || highlightTexts.length === 0) return

  const fullText = markdownBody.textContent || markdownBody.innerText

  highlightTexts.forEach(highlightText => {
    if (!highlightText || highlightText.trim() === '') return
    if (fullText.indexOf(highlightText) === -1) return

    const range = document.createRange()
    const walker = document.createTreeWalker(markdownBody, NodeFilter.SHOW_TEXT, null)

    let found = false
    let node
    while ((node = walker.nextNode()) && !found) {
      const text = node.textContent
      const index = text.indexOf(highlightText)

      if (index !== -1) {
        const parent = node.parentElement
        if (parent && parent.classList.contains('text-highlight')) {
          found = true
          continue
        }

        try {
          range.setStart(node, index)
          range.setEnd(node, index + highlightText.length)

          const span = document.createElement('span')
          span.className = 'text-highlight'
          span.style.setProperty('display', 'inline', 'important')
          span.style.setProperty('background-color', 'rgba(168, 85, 247, 0.4)', 'important')

          try {
            range.surroundContents(span) // 正常情况下直接包裹
          } catch (error) {
            // 如果 surroundContents 失败，先提取内容再插入
            const contents = range.extractContents()
            span.appendChild(contents)
            range.insertNode(span)
          }

          found = true
        } catch (error) {
          console.error('恢复高亮失败:', error)
        }
      }
    }
  })

  setTimeout(() => {
    const highlights = markdownBody.querySelectorAll('.text-highlight')
    highlights.forEach(hl => {
      hl.style.setProperty('display', 'inline', 'important')
      hl.style.setProperty('background-color', 'rgba(168, 85, 247, 0.4)', 'important')
    })
  }, 0)
}
```

## 移除高亮与状态同步

切换文章时，会调用 `removeHighlight`，把 `<span class="text-highlight">` 的子节点还原回父元素，并重新保存状态，确保视图与 `sessionStorage` 一致。

```javascript
// 清除当前文章的所有高亮（切换文章或手动重置时调用）
const removeHighlight = () => {
  const highlights = articleContentRef.value?.querySelectorAll('.text-highlight')
  if (highlights) {
    highlights.forEach(highlight => {
      const parent = highlight.parentNode
      if (parent) {
        while (highlight.firstChild) {
          parent.insertBefore(highlight.firstChild, highlight)
        }
        parent.removeChild(highlight)
        parent.normalize() // 合并相邻文本节点，保持 DOM 整洁
      }
    })
  }
  saveHighlights()
}
```

---

## 视觉样式与交互反馈

最终的高亮样式在组件末尾定义，统一设置背景色、行高和列表场景下的对齐方式，确保渲染后的段落不会错位。

```vue
.article-content .text-highlight,
.markdown-body .text-highlight,
.text-highlight {
  background: rgba(168, 85, 247, 0.4) !important;
  color: inherit !important;
  display: inline !important;
  padding: 0 !important;
  margin: 0 !important;
  line-height: inherit !important;
  border-radius: 3px !important;
}

.markdown-body li .text-highlight,
.article-content li .text-highlight {
  display: inline !important;
  padding: 0 2px !important;
}
```

## 高亮数据清理

当手动清除缓存时，会调用 `clearAllHighlights`，遍历 DOM 中的 `.text-highlight` 元素，把子节点还原到父容器，并重新保存状态，确保 `sessionStorage` 与视图同步。
