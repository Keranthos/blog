## 问题背景

在这个博客网站里面，我为管理员（当然也就是我自己）身份留下了写文章的入口而非使用静态文件展示。如图所示：

https://i.33xp.cn/__imgapi.cn__/__imgapi.cn__5e05a2a387faa.jpg?t=1762524471&t=1762524473952

![image-20251107174147340](C:\Users\wanweijie\AppData\Roaming\Typora\typora-user-images\image-20251107174147340.png)

同时每一篇文章需要一张头图，否则非常不美观。但是并不是所有文章我都能拿出来一张图片作为头图的，因此就必须要使用图床API接口，让我在拿不出头图的时候随机选一张好看的用。当然这就引起了一系列问题，包括：

- **稳定性差**：第三方图床可能失效，导致图片404
- **加载速度慢**：跨域请求增加延迟
- **其他风险：**要是这个图床失效了，这条外链被被指向了一张违法的图片或者是涩图那我不是炸了吗

所以我决定把这些外链图片本地化，用服务器的空间来换取加载的时间并且规避一些可能的危险



## 设计

本地化的过程其实很简单：

在前端如果上传了图片（要先暂存在浏览器中获取一个临时地址，否则无法预览），在传回后端时就获取这张图片、存进文件系统、获取URL替换在数据库对应的字段/正文中；

如果没有就需要识别一下是否是外链的图片，开始走下载、转存、获取URL、写进数据库的流程

```
┌─────────────────┐
│   前端提交      │
│  (文章/媒体)    │
└────────┬────────┘
         │
         ▼
┌─────────────────┐
│  后端控制器     │
│  (Article/Media)│
└────────┬────────┘
         │
         ▼
┌─────────────────┐      ┌──────────────────┐
│  URL识别模块    │─────▶│  外链图片？      │
│ IsExternalURL   │      │  是 → 继续处理   │
└────────┬────────┘      │  否 → 直接返回   │
         │               └──────────────────┘
         ▼
┌─────────────────┐
│  安全验证模块   │
│  SSRF防护       │
└────────┬────────┘
         │
         ▼
┌─────────────────┐
│  图片下载模块   │
│  FetchAndStore  │
└────────┬────────┘
         │
         ▼
┌─────────────────┐
│  MIME验证模块   │
│  内容类型检测   │
└────────┬────────┘
         │
         ▼
┌─────────────────┐
│  文件存储模块   │
│  哈希命名+分桶  │
└────────┬────────┘
         │
         ▼
┌─────────────────┐
│  返回本地URL    │
│  /uploads/...   │
└─────────────────┘
```



## 功能实现

### 外链图片识别

首先要判断一个URL是否为需要本地化的外链图片，目前只检查使用的图床API的HTTP/HTTPS协议：

```go
// IsExternalImageURL 判断是否为需要本地化的外链图片
func IsExternalImageURL(raw string) bool {
    if raw == "" {
        return false
    }
    // 已经是本地路径，不需要处理
    if strings.HasPrefix(raw, "/uploads/") || strings.HasPrefix(raw, "uploads/") {
        return false
    }
    // 解析URL，检查是否为HTTP/HTTPS协议
    u, err := url.Parse(raw)
    if err != nil {
        return false
    }
    if u.Scheme != "http" && u.Scheme != "https" {
        return false
    }
    return true
}
```

### SSRF防护

其实这里做SSRF防护的需求并不是很高，毕竟这个URL上传的功能只有我一个来着……我也不太可能闲着没事攻击自己的系统玩儿（其实真的很难说，毕竟人闲下来干什么都有可能），但是既然写到了外链本地化的地方不如就试着写一个简单的防护。

> **SSRF（Server-Side Request Forgery）** 是一种安全漏洞，攻击者可以诱导Web（或其他处理公网请求的）服务器向内网发起请求，从而返回内网的一些私密数据。这个攻击最著名的是对AWS（亚马逊的云服务计算平台）的攻击中，攻击的哥们好像还把拿到的数据全部公开在`github`上面，太有开源精神了。具体可以查看这个视频：https://www.bilibili.com/video/BV1Wt2TBgENT/?spm_id_from=333.337.search-card.all.click

```go
// isPrivateIP 检查IP是否为私有地址
func isPrivateIP(ip net.IP) bool {
    // 检查回环地址和链路本地地址
    if ip.IsLoopback() || ip.IsLinkLocalUnicast() || ip.IsLinkLocalMulticast() {
        return true
    }
    // 检查私有网络段
    privateBlocks := []string{
        "10.0.0.0/8",        // A类私有网络
        "172.16.0.0/12",     // B类私有网络
        "192.168.0.0/16",    // C类私有网络
        "127.0.0.0/8",       // 回环地址
        "::1/128",           // IPv6回环
        "fc00::/7",          // IPv6私有网络
        "fe80::/10",         // IPv6链路本地
    }
    for _, cidr := range privateBlocks {
        _, block, _ := net.ParseCIDR(cidr)
        if block.Contains(ip) {
            return true
        }
    }
    return false
}

// 在下载前进行安全检查
u, err := url.Parse(raw)
if err != nil {
    return "", err
}
// DNS解析，获取所有IP地址
ips, err := net.LookupIP(u.Hostname())
if err != nil {
    return "", err
}
// 检查是否有私有IP
for _, ip := range ips {
    if isPrivateIP(ip) {
        return "", errors.New("blocked private address")
    }
}
```

### 图片下载与存储

图片下载就没有什么好说的，就是注意一下大小和请求时间的限制，如果下载出现问题就返回提示给前端重新选择一张

```go
const (
    maxDownloadBytes int64 = 5 * 1024 * 1024 // 5MB 上限
    httpTimeout            = 12 * time.Second
)

// FetchAndStoreImageTo 下载并保存外链图片
func FetchAndStoreImageTo(raw string, subdir string) (string, error) {
    // 1. 判断是否为外链
    if !IsExternalImageURL(raw) {
        return raw, nil
    }

    // 2. SSRF防护（前面已展示）
    // ...

    // 3. 创建HTTP客户端，配置超时和重定向限制
    client := &http.Client{
        Timeout: httpTimeout,
        CheckRedirect: func(req *http.Request, via []*http.Request) error {
            // 最多允许3次重定向，防止重定向攻击
            if len(via) >= 3 {
                return errors.New("too many redirects")
            }
            return nil
        },
    }

    // 4. 构造请求，设置真实的User-Agent和Referer
    req, _ := http.NewRequest(http.MethodGet, raw, nil)
    req.Header.Set("User-Agent", "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36")
    req.Header.Set("Referer", "https://www.weibo.com/")
    req.Header.Set("Accept", "image/webp,image/apng,image/*,*/*;q=0.8")
    
    // 5. 执行请求
    resp, err := client.Do(req)
    if err != nil {
        return "", err
    }
    defer resp.Body.Close()
    
    if resp.StatusCode != http.StatusOK {
        return "", fmt.Errorf("bad status: %d", resp.StatusCode)
    }

    // 6. 限制体积并读取内容
    limited := io.LimitReader(resp.Body, maxDownloadBytes+1)
    buf, err := io.ReadAll(limited)
    if err != nil {
        return "", err
    }
    if int64(len(buf)) > maxDownloadBytes {
        return "", errors.New("image too large")
    }

    // 7. MIME类型验证（下一节详述）
    // ...

    // 8. 生成唯一文件名并存储
    // ...
}
```

构造请求的原因

- UA：如果使用Go语言的默认UA（如 `Go-http-client/1.1`）容易被识别为人机，做一点伪装成普通用户正常访问（虽然我确实是人机就是）

- `Referer`：简单地绕过一下防盗链机制，假装请求来自`weibo`（当然直接`no-referer`也是可以的）

  > 防盗链机制：一种服务器保护机制，旨在防止其他网站直接链接（盗用）自己的资源（图片、视频、文件等）。主要基于HTTP请求中的`Referer`（请求来源）判断来源是否属于自己的白名单

### MIME类型双重验证

既然已经写了SSRF防御，不如就把MIME双重验证（HTTP头+内容嗅探）也写一下

>**MIME**，全称是 **Multipurpose Internet Mail Extensions**（多用途互联网邮件扩展类型）。最初它为了电子邮件系统发明，让邮件不仅能传文字，还能传图片、音频、视频等附件。现在成为整个互联网上标识文件类型（媒体类型）的标准。工作核心是通过文件开头的特定字节序列（即“魔术字”）来识别文件类型

```go
var allowedImageMIMEs = map[string]string{
    "image/jpeg": ".jpg",
    "image/png":  ".png",
    "image/webp": ".webp",
    "image/gif":  ".gif",
}

// 1. 从HTTP响应头获取Content-Type
mimeType := resp.Header.Get("Content-Type")
if mimeType == "" {
    // 2. 如果响应头没有，通过内容嗅探
    mimeType = http.DetectContentType(buf)
}
// 3. 处理带参数的content-type（如：image/jpeg; charset=binary）
if mt, _, err := mime.ParseMediaType(mimeType); err == nil {
    mimeType = mt
}

// 4. 验证MIME类型是否在白名单中
ext, ok := allowedImageMIMEs[mimeType]




if !ok {
    return "", fmt.Errorf("unsupported mime: %s", mimeType)
}
```

### 哈希命名与分桶存储

为了防止无用的图片文件占用大量内存空间，所以我特意在管理员权限中写了一个图片管理（包括展示所有图片、检查图片目前是否被使用、点击跳转图片使用界面等功能，以后也许会详细介绍）的界面。因此图片命名与存储尤其重要。

命名使用的是 时间戳 + 内容哈希 + 随机数 的命名策略：

```go
// 生成唯一文件名
now := time.Now()
// 使用URL和内容计算SHA256哈希
h := sha256.Sum256(append([]byte(raw), buf...))
hashStr := hex.EncodeToString(h[:16]) // 使用前16字节

// 时间戳 + 哈希 + 纳秒级随机数 + 扩展名
filename := fmt.Sprintf("%s_%s_%d%s", 
    now.Format("20060102_150405"), 
    hashStr, 
    now.Nanosecond(), 
    ext)
```

存储就采用按业务和日期分桶的存储策略：

```go
// 创建日期子目录（YYYY/MM）以便管理
year := now.Format("2006")
month := now.Format("01")

dir := filepath.Join("uploads", "images")
if subdir != "" {
    // 有子目录：uploads/images/{subdir}/YYYY/MM
    // 例如：uploads/images/media/2024/01
    dir = filepath.Join(dir, subdir, year, month)
} else {
    // 无子目录：uploads/images/YYYY/MM
    // 例如：uploads/images/2024/01
    dir = filepath.Join(dir, year, month)
}

os.MkdirAll(dir, 0755)
```

**目录结构示例**：
```
uploads/images/
├── content/          # 文章正文中的图片
│   ├── 2024/
│   │   ├── 01/
│   │   └── 02/
│   └── 2025/
│       └── 01/
├── media/            # 书影集封面
│   └── 2024/
│       └── 12/
└── articles/         # 文章封面（可选）
    └── 2024/
        └── 11/
```

## 总结

| 注意事项 | 实现方式 | 防护目标 |
|---------|---------|---------|
| SSRF防护 | IP地址白名单检查 | 防止访问内网服务 |
| MIME验证 | 双重验证（响应头+内容嗅探） | 防止恶意文件上传 |
| 体积限制 | 5MB上限 | 防止资源耗尽 |
| 超时控制 | 12秒超时 | 防止长时间阻塞 |
| 重定向限制 | 最多3次 | 防止重定向攻击 |
| 文件扩展名验证 | 白名单机制 | 防止执行恶意脚本 |
